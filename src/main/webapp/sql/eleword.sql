/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50520
Source Host           : localhost:3306
Source Database       : eleword

Target Server Type    : MYSQL
Target Server Version : 50520
File Encoding         : 65001

Date: 2014-04-02 17:28:47
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `article`
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `author` varchar(255) NOT NULL,
  `category_id` bigint(20) DEFAULT NULL,
  `content` text NOT NULL,
  `keywords` varchar(255) DEFAULT NULL,
  `modify_date` datetime DEFAULT NULL,
  `post_date` datetime DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `title` varchar(255) NOT NULL,
  `views` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('1', 'zhagnsan', '1', '<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">1. find</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">find的使用格式如下：</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">- &lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">- &lt;指定条件&gt;： 所要搜索的文件的特征。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">- &lt;指定动作&gt;： 对搜索结果进行特定的处理。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">find的使用实例：</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ find . -name \'my*\'</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ find . -name \'my*\' -ls</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ find . -type f -mmin -10</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">2. locate</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">locate命令其实是\"find -name\"的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">locate命令的使用实例：</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ locate /etc/sh</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">搜索etc目录下所有以sh开头的文件。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ locate ~/m</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">搜索用户主目录下，所有以m开头的文件。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ locate -i ~/m</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">搜索用户主目录下，所有以m开头的文件，并且忽略大小写。</span> \r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">3. whereis</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">whereis命令的使用实例：</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ whereis grep</span> \r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">4. which</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">which命令的使用实例：</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ which grep</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\"></span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">5. type</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">type命令的使用实例：</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ type cd</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">系统会提示，cd是shell的自带命令（build-in）。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ type grep</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">系统会提示，grep是一个外部命令，并显示该命令的路径。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">$ type -p grep</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">加上-p参数后，就相当于which命令。</span> \r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>', null, null, '2014-04-01 15:37:59', '0', 'Linux的五个查找命令', '0');
INSERT INTO `article` VALUES ('2', 'zhagnsan', '1', '<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">一. Grep&nbsp;说明</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">grep (global search regular expression(RE) and print out the line)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> Unix的grep家族包括grep、&nbsp;egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符，&nbsp;fgrep就是&nbsp;fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> linux&nbsp;使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">grep在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到屏幕，不影响原文件内容。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。&nbsp;利用这些返回值就可进行一些自动化的文本处理工作。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> </span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">二.&nbsp;&nbsp;grep正则表达式元字符集(基本集)</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（1）^：&nbsp;锚定行的开始&nbsp;如：\'^grep\'匹配所有以grep开头的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（2）$：锚定行的结束&nbsp;如：\'grep$\'匹配所有以grep结尾的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（3）. :匹配一个非换行符的字符&nbsp;如：\'gr.p\'匹配gr后接一个任意字符，然后是p。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（4）*：匹配零个或多个先前字符&nbsp;如：\'*grep\'匹配所有一个或多个空格后紧跟grep的行。&nbsp;.*一起用代表任意字符。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（5）[]：匹配一个指定范围内的字符，如\'[Gg]rep\'匹配Grep和grep。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（6）[^]：匹配一个不在指定范围内的字符，如：\'[^A-FH-Z]rep\'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（7）/(../)&nbsp;：标记匹配字符，如\'/(love/)\'，love被标记为1。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（8）/&lt; ：锚定单词的开始，如:\'//&gt;</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">锚定单词的结束，如\'grep/&gt;\'匹配包含以grep结尾的单词的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（9）x/{m/}：重复字符x，m次，如：\'0/{5/}\'匹配包含5个0的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（10）x/{m,/}：重复字符x,至少m次，如：\'o/{5,/}\'匹配至少有5个o的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（11）x/{m,n/}：重复字符x，至少m次，不多于n次，如：\'o/{5,10/}\'匹配5--10个o的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（12）/w：匹配文字和数字字符，也就是[A-Za-z0-9]，如：\'G/w*p\'匹配以G后跟零个或多个文字或数字字符，然后是p。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（13）/W：/w的反置形式，匹配一个或多个非单词字符，如点号句号等。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（14）/b：单词锁定符，如: \'/bgrepb/\'只匹配grep。</span> \r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">三.&nbsp;用于egrep和&nbsp;grep -E的元字符扩展集</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（1）+：匹配一个或多个先前的字符。如：\'[a-z]+able\'，匹配一个或多个小写字母后跟able的串，如loveable,enable,disable等。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（2）?：匹配零个或多个先前的字符。如：\'gr?p\'匹配gr后跟一个或没有字符，然后是p的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（3）a|b|c：匹配a或b或c。如：grep|sed匹配grep或sed</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（4）()&nbsp;：分组符号，如：love(able|rs)ov+匹配loveable或lovers，匹配一个或多个ov。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（5）x{m},x{m,},x{m,n}：作用同x/{m/},x/{m,/},x/{m,n/}</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> </span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">四. POSIX字符类</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是A-Za-z0-9的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[: alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（1）[:alnum:]&nbsp;文字数字字符</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（2）[:alpha:]&nbsp;文字字符</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（3）[:digit:]&nbsp;数字字符</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（4）[:graph:]&nbsp;非空字符(非空格、控制字符)</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（5）[:lower:]&nbsp;小写字符</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（6）[:cntrl:]&nbsp;控制字符</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（7）[:print:]&nbsp;非空字符(包括空格)</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（8）[:punct:]&nbsp;标点符号</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（9）[:space:]&nbsp;所有空白字符(新行，空格，制表符)</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（10）[:upper:]&nbsp;大写字符</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（11）[:xdigit:]&nbsp;十六进制数字(0-9，a-f，A-F)</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> </span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">五. Grep命令选项</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（1）-?：同时显示匹配行上下的？行，如：grep -2 pattern filename同时显示匹配行的上下2行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（2）-b，--byte-offset&nbsp;：打印匹配行前面打印该行所在的块号码。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（3）-c,--count：只打印匹配的行数，不显示匹配的内容。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（4）-f File，--file=File：从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（5）-h，--no-filename：当搜索多个文件时，不显示匹配文件名前缀。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（6）-i，--ignore-case：忽略大小写差别。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（7）-q，--quiet：取消显示，只返回退出状态。0则表示找到了匹配的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（8）-l，--files-with-matches：打印匹配模板的文件清单。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（9）-L，--files-without-match：打印不匹配模板的文件清单。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（10）-n，--line-number：在匹配的行前面打印行号。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（11）-s，--silent：不显示关于不存在或者无法读取文件的错误信息。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（12）-v，--revert-match：反检索，只显示不匹配的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（13）-w，--word-regexp：如果被/&lt;和/&gt;引用，就把表达式做为一个单词搜索。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（14）-V，--version：显示软件版本信息。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> </span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">六.&nbsp;实例</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（1）$ ls -l | grep \'^a\'</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">通过管道过滤ls -l输出的内容，只显示以a开头的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（2）$ grep \'test\' d*</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">显示所有以d开头的文件中包含test的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（3）$ grep \'test\' aa bb cc</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">显示在aa，bb，cc文件中匹配test的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（4）$ grep \'[a-z]/{5/}\' aa</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（5）$ grep \'w/(es/)t.*/1\' aa</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.*)，这些字符后面紧跟着另外一个es(/1)，找到就显示该行。如果用egrep或grep -E，就不用\"/\"号进行转义，直接写成\'w(es)t.*/1\'就可以了。</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（6）cat /etc/oratab |grep -v ^#|grep -v ^$|grep -v \'^;\'</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> 过滤注释</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">[root@rac1 ~]# cat /etc/oratab</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">#</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> </span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"># This file is used by ORACLE utilities.&nbsp;&nbsp;It is created by root.sh</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"># and updated by the Database Configuration Assistant when creating</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"># a database.</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> </span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"># A colon, \':\', is used as the field terminator.&nbsp;&nbsp;A new line terminates</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"># the entry.&nbsp;&nbsp;Lines beginning with a pound sign, \'#\', are comments.</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">#</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"># Entries are of the form:</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">#&nbsp;&nbsp;&nbsp;$ORACLE_SID:$ORACLE_HOME:<n|y>:</n|y></span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">#</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"># The first and second fields are the system identifier and home</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"># directory of the database respectively.&nbsp;&nbsp;The third filed indicates</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"># to the dbstart utility that the database should , \"Y\", or should not,</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"># \"N\", be brought up at system boot time.</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">#</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"># Multiple entries with the same $ORACLE_SID are not allowed.</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">#</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> </span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">+ASM1:/u01/app/oracle/product/10.2.0/db_1:N</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">rac:/u01/app/oracle/product/10.2.0/db_1:N</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> </span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">过滤之后：</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">[root@rac1 ~]# cat /etc/oratab |grep -v ^#|grep -v ^$|grep -v \'^;\'</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">+ASM1:/u01/app/oracle/product/10.2.0/db_1:N</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">rac:/u01/app/oracle/product/10.2.0/db_1:N</span> \r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\"> </span> \r\n</p>', null, '2014-04-02 06:20:55', '2014-04-01 15:48:24', '0', 'Linux Grep 命令说明', '0');
INSERT INTO `article` VALUES ('3', 'zhagnsan', '1', '<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;\">//有空就更新</span>\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;\">替换文本</span>\r\n</h3>\r\n<div>\r\n	<span style=\"font-size:14px;\"># 把 test 开头文件中的 Windows 换成 Linux# -i[extension]     edit &lt;&gt; files in place (makes backupifextension supplied)# -e program        onelineof program (several -e\'s allowed, omit programfile)# -p                assume loop like -n but printlinealso, like sed# -n                assume \"while (&lt;&gt;) { ... }\" loop around programperl -i -pe\'s/Windows/Linux/;\'test*</span>\r\n</div>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;\">压缩/解压相关</span>\r\n</h3>\r\n<div>\r\n	<span style=\"font-size:14px;\"># pigz 是 gz 的多核版tar cvf - paths-to-archive | pigz &gt; archive.tar.gz# 使用 -p 指定核数tar cvf - paths-to-archive | pigz -9-p32&gt; archive.tar.gz</span>\r\n</div>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;\">确定系统性能的情况(其实更重要的是对数据的解读)</span>\r\n</h3>\r\n<h4 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;\">网络流量监控</span>\r\n</h4>\r\n<div>\r\n	<span style=\"font-size:14px;\">ar-n DEV11000</span>\r\n</div>\r\n<h4 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;\">磁盘IO</span>\r\n</h4>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>\r\n<div>\r\n	<span style=\"font-size:14px;\">iostat-dxk11000</span>\r\n</div>\r\n<h4 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;\">CPU</span>\r\n</h4>\r\n<div>\r\n	<span style=\"font-size:14px;\">top# orvmstat</span>\r\n</div>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;\">参考</span>\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<ul>\r\n		<li>\r\n			<a href=\"http://stackoverflow.com/questions/12313242/utilizing-multi-core-for-targzip-bzip-compression-decompression\"><span style=\"font-size:14px;\">Utilizing multi core for tar+gzip/bzip compression/decompression</span></a> \r\n		</li>\r\n		<li>\r\n			<a href=\"http://blog.jobbole.com/60549/\"><span style=\"font-size:14px;\">每个极客都应该知道的Linux技巧</span></a> \r\n		</li>\r\n	</ul>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>', null, null, '2014-04-02 10:35:08', '0', 'Linux上有用的命令', '0');
INSERT INTO `article` VALUES ('4', 'zhagnsan', '2', '<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">上次写了一篇文章：</span><a href=\"http://www.zavakid.com/70\" target=\"_blank\"><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">Unix IO 模型学习</span></a><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">。恰巧在这次周会的时候，</span><a href=\"http://weibo.com/fp1203\" target=\"_blank\"><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">@fp1203</span></a><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">&nbsp;(</span><a href=\"http://www.goldendoc.org/\" target=\"_blank\"><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">goldendoc</span></a><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">成员之一) 正好在讲解poll和epoll的底层实现。中途正好讨论了网络IO的同步、异步、阻塞、非阻塞的概念，当时讲下来，大家的理解各不相同，各执己见。搜索了网络上的一些文章，观点也各不相同，甚至连</span><a href=\"http://en.wikipedia.org/wiki/Asynchronous_I/O\" target=\"_blank\"><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">wiki</span></a><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">也将异步和非阻塞当成一个概念在解释。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">虽然网络上充斥了大量关于同步、异步、阻塞、非阻塞的文章，但大都是抄来抄去，没有一个权威的说法。但我找到了</span><a href=\"http://blog.csdn.net/historyasamirror/article/details/5778378\" target=\"_blank\"><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">这一篇文章</span></a><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">，该文章引用了《UNIX网络编程 卷1》的介绍，这本书的作者是Richard Stevens。如果有Richard Stevens在这方面的定义或者结论，那么我想，这应该是比较有说服力的了。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">关于《UNIX网络编程 卷1》这本书，我特意找了英文原版，也共享出来了：大家可以下载</span><a href=\"http://u.115.com/file/bh06p2sr#UNIX_Network_Programming.chm\" target=\"_blank\"><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">《UNIX网络编程 卷1》的英文原版</span></a><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">（CHM格式）。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">我看了6.2这节内容，这节内容就是讲IO模型的。刚刚提到的那篇文章，几乎就是翻译这个6.2节的。应该说，这个6.2节，对同步和异步的讲解，算是很清楚的。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">下面是我自己理解的重点。</span>\r\n</p>\r\n<h3>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">IO模型</span>\r\n</h3>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">目前unix存在五种IO模型（这也和上一篇文章：</span><a href=\"http://www.zavakid.com/70\" target=\"_blank\"><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">Unix IO 模型</span></a><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">&nbsp;中提到的一致），分别是：</span>\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<ul>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">阻塞型 IO（blocking I/O）</span>\r\n	</li>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">非阻塞性IO（nonblocking I/O）</span>\r\n	</li>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">IO多路复用（I/O multiplexing）</span>\r\n	</li>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">信号驱动IO（signal driven I/O）</span>\r\n	</li>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">异步IO（asynchronous I/O）</span>\r\n	</li>\r\n</ul>\r\n<p>\r\n	<br />\r\n</p>\r\n<h3>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">IO的两个阶段</span>\r\n</h3>\r\n<p>\r\n	<br />\r\n</p>\r\n<ol>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">等待数据准备好</span>\r\n	</li>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">将数据从内核缓冲区复制到用户进程缓冲区</span>\r\n	</li>\r\n</ol>\r\n<p>\r\n	<br />\r\n</p>\r\n<h3>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">同步，异步的区别</span>\r\n</h3>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">那么究竟什么是同步和异步的区别呢？请重点读一下</span><a href=\"http://u.115.com/file/bh06p2sr#UNIX_Network_Programming.chm\" target=\"_blank\"><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">原文</span></a><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">6.2节中的信号驱动IO和异步IO中的比较。最后总结出来是：</span>\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<ul>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">同步IO，需要用户进程主动将存放在内核缓冲区中的数据拷贝到用户进程中。</span>\r\n	</li>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">异步IO，内核会自动将数据从内核缓冲区拷贝到用户缓冲区，然后再通知用户。</span>\r\n	</li>\r\n</ul>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">这样，同步和异步的概念就非常明显了。以上的五种IO模型，前面四种都是同步的，只有第五种IO模型才是异步的IO。</span>\r\n</p>\r\n<h3>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">阻塞和非阻塞</span>\r\n</h3>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">那么阻塞和非阻塞呢？注意到以上五个模型。阻塞IO，非阻塞IO，只是上面的五个模型中的两个。阻塞，非阻塞，是针对单个进程而言的。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">当对多路复用IO进行调用时，比如使用poll。需注意的是，poll是系统调用，当调用poll的时候，其实已经是陷入了内核，是内核线程在跑了。因此对于调用poll的用户进程来讲，此时是阻塞的。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">因为poll的底层实现，是去扫描每个文件描述符（fd），而如果要对感兴趣的fd进行扫描，那么只能将每个描述符设置成非阻塞的形式（对于用户进程来讲，设置fd是阻塞还是非阻塞，可以使用系统调用fcntl），这样才有可能进行扫描。如果扫描当中，发现有可读（如果可读是用户感兴趣的）的fd，那么select就在用户进程层面就会返回，并且告知用户进程哪些fd是可读的。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">这时候，用户进程仍然需要使用read的系统调用，将fd的数据，从内核缓冲区拷贝到用户进程缓冲区（这也是poll为同步IO的原因）。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">那么此时的read是阻塞还是非阻塞呢？这就要看fd的状态了，如果fd被设置成了非阻塞，那么此时的read就是非阻塞的；如果fd被设置成了阻塞，那么此时的read就是阻塞的。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">不过程序已经执行到了这时候，不管fd是阻塞还是非阻塞，都没有任何区别，因为之前的poll，就是知道有数据准备好了才返回的，也就是说内核缓冲区已经有了数据，此时进行read，是肯定能够将数据拷贝到用户进程缓冲区的。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">但如果换种想法，如果poll是因为超时返回的，而我们又对一个fd（此fd是被poll轮询过的）进行read调用，那么此时是阻塞还是非阻塞，就非常有意义了，对吧！</span>\r\n</p>\r\n<h3>\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">结论</span>\r\n</h3>\r\n<p>\r\n	<br />\r\n</p>\r\n<ol>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">判断IO是同步还是异步，是看谁主动将数据拷贝到用户进程。</span>\r\n	</li>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">select或者poll，epoll，是同步调用，进行此调用的用户进程也处于阻塞状态。</span>\r\n	</li>\r\n	<li>\r\n		<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">javaScript或者nodejs中的读取网络（文件）数据，然后提供回调函数进行处理，是异步IO。</span>\r\n	</li>\r\n</ol>\r\n<p>\r\n	<br />\r\n</p>', null, null, '2014-04-02 10:37:11', '0', '关于IO的同步,异步,阻塞,非阻塞', '0');
INSERT INTO `article` VALUES ('5', 'zhagnsan', '5', '<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">关于虚拟内存，物理内存，我有蛮多概念都是很模糊的，今天下午看了一下虚拟内存，也算是有了一点小收获，本文就针对为什么需要有虚拟内存的理解写下来。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">同时，我也希望自己能够陆续学习linux内存管理的知识，并且写出一些文章，来记录自己的一些理解。 如果您觉得有任何问题，可以留下评论，我们一起讨论，毕竟越辩越明。</span>\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">为什么要使用虚拟内存</span>\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">之前的计算机系统，是使用物理地址来使用内存的，这样，CPU就根据某个寄存器中相应的值，直接到物理内存去取值了。 这样的好处就是非常直接，非常容易理解。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">而缺点是，我们需要知道物理地址的值，每次程序开始执行，也就是执行程序从磁盘被load到物理内存中之后，我们必须告诉CPU，程序是从哪一个地址开始执行的（即PC寄存器的值）；还有一个致命的缺点是：程序使用的内存会被物理内存所限制，比如我们的机器上只有512M内存，那我们的程序就不能使用需占1G内存的程序了。这点或许是催生虚拟内存产生的最主要原因。</span>\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">虚拟内存的概念</span>\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">为了解决上面的的问题，就产生了虚拟内存的概念。那什么是虚拟内存呢？这里我先说说自己对存储器层次结构的理解。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">计算机中有一种存储器层次的原则。我的理解是，CPU使用的数据都是基于寄存器的，如果我们的寄存器足够的大和多并且足够便宜，那么也就没有后来那么多的东西产生了。而问题就是寄存器足够快，但其造价却非常昂贵，因此，考虑到成本，就有了之后的CPU高速缓存，主存（就是我们常说的内存）和硬盘，甚至磁带等存储器了。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">那么，计算机是如何让这些速度快慢不一、容量大小不一的存储器在一起工作的呢？一个方案就是存储器层次结构。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">对于这个存储器层次结构，我的理解是：CPU是和寄存器打交道的，但寄存器的容量毕竟有限，因此就需要高速缓存存储器来作为寄存器的缓存，当有些数据在寄存器中找不到时，CPU就可以去寻找高速缓存这个存储器中的内容，如果告诉缓存器还没有这个数据，那我就去主存中再去寻找这个数据，如果主存中也还没有，那就去磁盘中找吧。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">这也是我对存储器层次结构的一个理解。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">以上说了一通，但都没有提到虚拟内存，那虚拟内存究竟是什么？他在这个层次中处于哪个位置呢？</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">实际上，按照这种模型去思考的话，就可以这样理解：虚拟内存就是去解决主存到磁盘这个层次的方案。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">没错，我认为虚拟内存就是一种方案，而且他是非常重要的，为什么呢？众所周知，CPU的速度很快，内存就是作为匹配CPU和磁盘之间速度的一个中间层，高速缓存其实也是这样一个缓存的角色，但问题是，如果高速缓存失效，那么CPU会去访问内存，这样的速度只是降低了十倍的数量级；而如果是内存失效，让CPU去访问磁盘的话，这样的速度却是降低了十万倍到百万倍的数量级。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">可见，在寄存器、高速缓存和主存之间缓存的失效，结果还是可以让人接受的（想想java的volatile关键字），但主存和磁盘之间缓存的失效，就会给程序造成比较大的性能影响了，所以我们应该努力避免主存的失效，这也是虚拟内存所必须要解决和面对的问题之一。</span>\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">总结</span>\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">其实可以认为，程序使用的内存，都是用的虚拟内存，因此也就没有了物理内存的限制（但还是限制于计算机的寻址位数，比如32位和64位，因为虚拟内存系统需要使用到物理内存）。他可以把自己的一部分放在物理内存中，还有一部分当做缓存放到磁盘中。另外，虚拟内存有相应的虚拟地址，因此，他就可以做到对于每一个程序来说，使用的都是相同的虚拟地址，这些虚拟地址，则可以映射到不同的物理地址，也就是说每个程序都可以把自己想象成自己拥有整台机器的内存。</span>\r\n</p>', null, null, '2014-04-02 10:37:36', '0', '内存学习——为什么需要虚拟内存', '0');
INSERT INTO `article` VALUES ('6', 'zhagnsan', '5', '<h3 style=\"text-indent:2em;\">\r\n	虚拟内存如何实现\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	虚拟内存是以虚拟页面的单位组成的。 虚拟页面使用磁盘来作为自己的存储，一些经常使用到的页面，才会被load到内存中，此时，就相当于把内存看成是磁盘的一个缓存。 因为每次都load到内存的是一个虚拟页面，所以对应的，内存就需要有一个物理页面能过装下这个虚拟页面。因此，物理内存也被分隔为一个一个的物理页面。虚拟页面和物理页面应该是相等的。 既然要把虚拟页面和物理页面关联起来，那么就需要维护虚拟页面和物理页面之间的关系。 因此，就又需要这样一张页面来维持这样的关系，通常，这张表是放在物理内存中，由操作系统来维护的,叫做页表。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	基于这种实现，实际上虚拟内存就有能力<a href=\"http://www.zavakid.com/119\" target=\"_blank\">解决之前所遇到的问题</a>：每个进程都可以使用相同的虚拟地址，操作系统会将虚拟地址翻译成不同的物理地址，但对进程来说，是透明的；每个进程也都不会因为物理内存受限而不能加载运行，实际上虚拟内存是存在磁盘的，而通常磁盘要比内存大很多（虚拟页面一般放在磁盘的swap分区）；同时，虚拟内存通过维护虚拟页面和物理页面的页面，可以实现权限控制，而这种权限控制，就是搭载在页面上面的，因此，一般的内存权限控制，都是以页为单位的。\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	虚拟内存的访问过程\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	当程序访问的虚拟地址在页表中找不到对应的物理页时，这时候，就会向磁盘读取此虚拟页面，并且将此虚拟页面与一个物理页面关联起来，并且在页面记录这种关系。当物理页面都已经被占满的时候，操作系统就会踢掉一个用的少的物理页面，从而让这个新的虚拟页面装入物理页面。 —— 这和我们使用缓存的逻辑没有什么不同 —— 操作系统将虚拟页面放入物理页面的动作，是由异常机制触发的。 而当程序中访问的虚拟地址已经在页表中有对应的物理页面时，这一切就变得相当轻松了。同时，内存权限的控制，也是通过在页表中的记录进行的。\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	总结\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	虚拟内存通过一个存储器层次的概念，将使用物理内存碰到的几个限制，就都统统解决了。我想，这和大学时候老师教我们在解决难题时候的思路一样，进行空间的坐标转换，换个角度，问题说不定就得以迅速解决，而且简单，高效。\r\n</p>', null, null, '2014-04-02 10:38:29', '0', '内存学习——虚拟内存', '0');
INSERT INTO `article` VALUES ('7', 'zhagnsan', '5', '<p style=\"text-indent:2em;\">\r\n	之前简单的看了一下&nbsp;<a href=\"http://fallabs.com/tokyotyrant/\" target=\"_blank\">Tokyo Tyrant</a>(包括&nbsp;<a href=\"http://fallabs.com/tokyocabinet/\" target=\"_blank\">Tokyo Cabint</a>) 在 hash 存储上的一些实现，最近&nbsp;<a href=\"http://redis.io/\" target=\"_blank\">Redis</a>&nbsp;又比较火热，因此，自己也尝试性的去了解了一下 Redis，并且结合 Tokyo Tyrant（以下简称 tt server），说说自己对这两种产品的看法。\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	服务端处理模型\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	在 tt server 中，是以多线程的方式向客户端提供服务的：一个主线程负责 accept 客户端的socket，一定数目的线程（可以指定）进行读写服务，同时，也有一定数目的timer线程，专门用来负责定时的任务，比如一些定时的&nbsp;<a href=\"http://www.lua.org/\" target=\"_blank\">Lua</a>&nbsp;脚本，同时，如果是slaver，则会有专门一个timer线程，定时负责 do slave 的工作。 而在 Redis 中，采用的则是单线程的模型来处理所有的客户端请求。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	应该说这两种模型，都有各自的优点和缺点。多线程可以利用多核CPU的计算能力，但因此也会增加CAS自旋或者是锁的一些消耗，同时，如果线程过多，那么线程之间上下文的切换，也是一种消耗。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	而如果是单线程，则可以完全避免锁的消耗，同时，上下文切换消耗也不需要过多的考虑（但仍需要考虑系统上还有其他的进程），这会让单个CPU的利用率比较高。 但是，单线程服务，就意味着不能利用多核。同时，服务端对客户端过来的请求是串行执行和响应的，这也在一定程度上，会影响服务端的并发能力，特别是在有些请求执行比较耗时的情况下。想象一下，就这么一个线程，可能正在拼命的执行客户端A的一个请求，而此时客户端B，C，D的请求，还仍在等着线程执行完成之后再去搭理他们。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	因此，像 redis 这种单线程的服务模型，如果对一些请求的处理相对较耗时，那其 TPS 也就相应的不能提高上去，也就是说其吞吐量会提不上去；但反过来想， redis 如果能控制每次请求在执行过程是简短并且快速的，那么也许使用单线程，反而会比多线程有更好的性能，毕竟单线程少了上下文切换，以及锁或者 cas 的开销。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	而 tt server 则中规中矩：一个线程负责 accept ，一定数目的线程则进行请求的处理。因此，我们在设置 tt server 的时候，也应尽量考虑好工作线程的数目，尽量让CPU数目与工作线程数目一致或者略少。原则是最好的发挥多核CPU的作用，同时又不让工作线程之间去竞争CPU。当然，这是需要不停的去实验的。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	所以，在使用 redis 的时候，应尽量不要去使用一些相对耗时的请求；同时，我想 redis 的作者，也应该会尽量优化每种请求的执行速度（至少是一些常用的请求）。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	而在使用 tt server 的时候，需要仔细调整使用的工作线程数目，让每个CPU都物尽其用。\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	数据存储方式、持久化比较\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	tt server 的 hash 数据库，是使用文件的方式，然后利用&nbsp;<a href=\"http://kernel.org/doc/man-pages/online/pages/man2/munmap.2.html\" target=\"_blank\">mmap</a>&nbsp;系统调用映射到内存中。 这样，就可以利用操作系统的机制，不定期地将数据 flush 到磁盘中。同时，tt server 也提供了 sync 命令，可以让客户端手动将数据 flush 到磁盘中(使用 msync 系统调用)。最后，在关闭 tt server 进程的时候，应该使用 kill -15(TERM信号)，或者使用 ttserver 自带的命令：ttserver -kl pid 进行关闭。这样 ttserver 会先把数据 flush 到磁盘上，再退出进程。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	同时， tt server 也提供了 ulog 的方式，对数据库的变更操作进行记录，同样，<a href=\"http://fallabs.com/tokyotyrant/spex.html#tutorial\" target=\"_blank\">可以利用 ulog 对 ttserver 进行恢复</a>，但 ulog 的主要目的，按照我的理解，应是用来实现 replication 的。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	而 redis 则是将数据直接写在了内存中，然后利用&nbsp;<a href=\"http://redis.io/topics/persistence\" target=\"_blank\">redis 的持久化机制</a>，将数据写到磁盘中。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	redis 提供了两种持久化机制，分别是 RDB （redis DB） 和 AOF （appending only file）。 RDB的过程是：redis 进程 fork 一个子进程，然后子进程对内存中的数据写到一个临时文件，这个时候，两个进程就利用了操作系统的 copy on write 机制，共享一份内存数据，只有当父进程（也就是 redis 进程）对原有的数据进行修改或者删除之后，操作系统才为 redis 进程重新开辟新的内存空间（以页为单位）。Redis 本身也提供了 bgsave（background save） 命令支持手动将数据持久化（ save 命令是同步的，而 redis 只有一个线程在服务，结果就是影响 redis 的性能，特别是在大数据量的情况下）。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	AOF的过程是：在执行每次命令之后，或者每隔1秒钟之后，Redis会有一个线程将命令以 redis 协议的格式 append 到文件中，这也就是AOF名字的由来，这些命令当然是非只读的，只读不更改数据库，没有必要记录下来。 这里会有两个问题： 1、每次命令之后写文件，还是隔1秒之后写文件，影响会有哪些？ 2、这些文件总会不断的膨胀，如何对文件进行压缩呢？\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	对于第一个问题，也是一个权衡的问题，如果每次命令之后都进行一次写磁盘操作，那么IO的程度可想而知，肯定会影响服务器性能(使用 write 系统调用，会因为文件系统而进入 page buffer，并非立刻写磁盘，而调用 fsync ，则会将 page buffer 中的数据写入磁盘，进行 IO 操作)。而如果每隔1秒进行一次 fsync，那么在这一秒和上一秒之间，如果服务器突然断电，那很有可能这些数据就会丢失。对于这个问题，redis 默认给出的方案是每隔1秒进行一次write。对于1秒的给定，我想，也是基于性能和数据安全的权衡，在性能和数据安全方面都可以让人接受。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	对于第二个问题，redis 提供了 rewrite 的机制：当 aof 过大的时候，redis可以自动的进行 rewrite （从 redis 2.4 开始）。rewrite 的过程也是 fork 一个子进程；然后打开一个临时文件，将内存中的数据写入到文件中；在此期间，主进程继续将数据写入老的 aof 文件，同时也会将数据写入到一个内存缓存中；等子进程完成之后，主进程会将缓存中的数据写入到临时文件，再将临时文件进行rename，替换掉原来的文件。这样，就实现了写 aof 过程中的rewrite。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	从数据的存储方式来说，尽管 tt server 和 redis 都是在内存上面进行数据的读写，我但认为两个产品对数据存储方式的观点是不一样的。 tt server 是将磁盘上的文件当作主要的存储方式，然后使用 mmap 将文件映射到内存中。本质上，这是数据应该存储在磁盘中的观点。 而 redis ，一开始就是将数据直接存储在内存中，在之后的持久化过程中，可以理解成只是将数据的日志写入到磁盘中。本质上，这是把数据应该存储在内存中的观点。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	可见，由于作者的观点不一样，也就造成了两种实现方式不一样的产品，这还是比较有意思的。 从这个层面上来讲，我更加喜欢 redis 作者的思路，很可能作者就是受到&nbsp;<a href=\"http://www.infoq.com/cn/news/2008/07/ram-is-disk\" target=\"_blank\">内存是新的磁盘，磁盘是新的磁带</a>&nbsp;的启发。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	redis自带实现的VM将在以后不再使用(2.4将是最后一个自带vm功能的版本)，作者认为数据就应该是放在物理内存中的，没有必要要将数据交换到磁盘中，磁盘只是作为日志的一种存储方式。这也是“内存是新的硬盘”思路的体现。\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	复制方式比较\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	tt server 和 redis 都支持 master-slave 方式的通信复制。 tt server 使用了 ulog，并且 slaver 使用了 rts（replication time-stamp） 文件，对上一次的复制时间戳进行保存，实现了复制的续传。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	而 redis 则是每次 slave 重新连接到 master 时，master 会将数据进行全量的复制给 slave，而不是增量式的。redis 复制的方式与使用 RDB 持久化方式原理基本相同，也是使用子进程进行内存的dump，在此期间，父进程收集改变数据库的命令，等把子进程收集的数据传输给 slave 之后，再将此期间收集到的数据也传输给 slave。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	如果从 slave 数据重建的角度来看，tt server 支持断点复制的实现，应该说是比 redis 先进了一步。\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	性能方面比较\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	新浪的 Tim Yang 做了&nbsp;<a href=\"http://timyang.net/data/mcdb-tt-redis/\" target=\"_blank\">memcacheDB、Redis、tt server 的性能测试</a>。这是比较早期的测试，相信随着版本的升级，两者的性能都会有所提升。不过按照这个测试的结果来看，redis 在数据量不多（500W）并且value 较小的时候，性能表现是很优越的；而对于稍大一些的 value ，tt 则在写方面表现很出色，但写的性能，相对较差。相比之下，redis的读写性能，倒是比较平衡。 但觉得随着时间的迁移，这个测试的参考性可能会打折扣，如果有可能的话，希望能看到更多的测试结果。\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	总结\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<ol>\r\n		<li>\r\n			<p>\r\n				从服务器模型来说，tt server 使用 acceptor + workers 的方式提供服务，能够利用多核的性能，但随着而来的是一些同步、加锁的复杂和开销；而 redis 使用了单线程提供服务，利用不了多核，但如果能够将每次服务的速度控制下来，对单个CPU的利用率，反而可以提高。如果想利用机器的多核性能，也可以在一台机器上搭建多个 redis 实例，但可能更要考虑到机器的内存限制。\r\n			</p>\r\n		</li>\r\n		<li>\r\n			<p>\r\n				从数据存储的方式来说，尽管 tt server 和 redis 都是将数据存储在内存中，但我认为两个产品对“数据是如何存储”的观点是有所不同的。tt server 认为数据是存储在文件中的，只是通过内存映射，将对文件的操作转化成对内存的操作；而 redis 是直接将数据存储到内存中，之后再通过持久化等机制，将数据备份到磁盘中。虽然之前 redis 自己实现了 vm 功能，但redis 后续会取消掉自己实现的 vm 功能，按照“内存是最新的磁盘”这种思路，也就不难理解了：除了增加复杂度之外，还有一个因素，那就是 redis 不需要 vm，能存的数据大小，只能限制在物理内存的范围以内。 从这个方面来将，redis 后续的版本可能就会限制用户使用的数据库大小是要小于物理内存的，而如果使用 tt server ，则用户须让使用数据文件小于物理内存，否则，发生内存交换，是非常损性能的。 总而言之，在使用内存数据库的时候，应该有意识的对数据进行容量规划，避免出现物理内存不够而引起的内存交换。\r\n			</p>\r\n		</li>\r\n		<li>\r\n			<p>\r\n				tt server 和 redis 的策略都是从 slaver 配置 master ，而不是从 master 配置 slaver 关系，这样就减轻了 master 的负担，同时，master 不必知道自己有多少个 slaver ，就可以横向的扩增 slaver 。但 tt server 支持所谓的断点复制。需要考虑到的是 redis 在做 replication 的时候，是 fork 一个子进程工作的，如果有多个 replicate 的请求，redis 依然还是一个子进程在工作。这样也会对多个 slaver 产生一定的复制延时。\r\n			</p>\r\n		</li>\r\n		<li>\r\n			<p>\r\n				redis 在工作方式上，会 fork 子进程，因此 redis 在容量规划上，需要考虑到 redis fork 出子进程所需要的内存和 CPU，在最差的情况下：bgsave时候，父子两个进程虽然可以使用 copy on write 的好处，但如果在此期间整个表记录都被修改了，那就足足需要一倍的内存，否则，此时父进程会进行 copy ，父进程很可能没有内存可用，就需要进行内存交换，由此所带来的性能代价也是非常高的；与此同时，子进程子在 bgsave 的时候，需要对数据进行压缩，压缩是计算密集型的，因此最好不要和父进程使用同一个CPU，因为父进程使用了单线程事件处理的模型，这种模型的优点是充分利用CPU的资源，如果出现子进程与父进程抢CPU，那就得不偿失了。\r\n			</p>\r\n		</li>\r\n		<li>\r\n			<p>\r\n				redis 支持较多的数据结构，但在使用 sort 等时间复杂性较多的命令时，也会稍微的降低 redis 的性能，应该对这些耗时的命令进行一定的监控。\r\n			</p>\r\n		</li>\r\n	</ol>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>', null, null, '2014-04-02 10:39:06', '0', 'Tokyo Tyrant 与 Redis 的一些简单比较', '0');
INSERT INTO `article` VALUES ('8', 'zhagnsan', '5', '<p>\r\n	<span style=\"font-family:Microsoft YaHei;\">平时使用的是 ubuntu，难免就需要经常使用终端，之前一直用的是 ubuntu 自带的终端。后来找到了 terminator 这款非常不错的终端软件。（&nbsp;</span><a href=\"http://software.jessies.org/terminator/\"><span style=\"font-family:Microsoft YaHei;\">官方地址</span></a><span style=\"font-family:Microsoft YaHei;\">&nbsp;）</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-family:Microsoft YaHei;\">刚刚接触一款新的软件，使用上肯定比之前的慢。不过经过10分钟的使用，我发现 terminator 很容易上手，而且使用上非常方便，以致于我决定以后不管是在个人还是在公司的电脑上，都要慢慢的使用这款软，以提高自己的工作效率。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-family:Microsoft YaHei;\">ubuntu 默认的终端 —— gnome-terminal，只有 tab 这一概念，并且支持以&nbsp;alt + 数字&nbsp;的快捷键对 tab 进行切换；同时，还可以使用&nbsp;ctrl+shift+t&nbsp;的快捷方式新建 tab。并且，还有 bash 中 readline 默认提供的 emacs 快捷键（当然，你也可以设置成 vi mode，想想可以用 vi 模式在 sh 下操作的快感吧 :-) ）。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-family:Microsoft YaHei;\">不过，所有 gnome-terminal 有的功能， terminator 都有。出此之外，terminator 还提供了一些很方便的功能：</span>\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<ul>\r\n	<li>\r\n		<span style=\"font-family:Microsoft YaHei;\">允许在一个 tab 中打开多个终端 —— 这个可以满足我一边&nbsp;man&nbsp;一个命令，一边练习</span>\r\n	</li>\r\n	<li>\r\n		<span style=\"font-family:Microsoft YaHei;\">允许同时操作多个终端 —— 这个功能使用的场景不多。但可以想象，如果你同时操作多台服务器，倒可以使用使用。先cd回到HOME，然后就进行自己的命令了。</span>\r\n	</li>\r\n</ul>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	<span style=\"font-family:Microsoft YaHei;\">terminator默认的快捷键没有alt+number，所以我自己设置了一份快捷键，并放在了：</span><a href=\"https://github.com/zavakid/terminator-config\"><span style=\"font-family:Microsoft YaHei;\">github terminator config</span></a><span style=\"font-family:Microsoft YaHei;\">&nbsp;上，欢迎大家fork之。另外关于 terminator 的僵尸进程问题，已有解决方案，</span><a href=\"http://www.zavakid.com/2012/10/09/terminator_in_ubuntu_bugfix\"><span style=\"font-family:Microsoft YaHei;\">详见这里</span></a><span style=\"font-family:Microsoft YaHei;\">。</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-family:Microsoft YaHei;\">下面是使用的几张截图：</span>\r\n</p>\r\n<p>\r\n	<span style=\"font-family:Microsoft YaHei;\"></span><img src=\"http://pic.yupoo.com/zavakid/BXuv7KOo/medium.jpg\" alt=\"同一tab下多个终端\" style=\"height:auto;\" /> \r\n</p>\r\n<p>\r\n	<img src=\"http://pic.yupoo.com/zavakid/BXuvasam/medium.jpg\" alt=\"广播命令，同时操作多个终端\" style=\"height:auto;\" /> \r\n</p>\r\n<p>\r\n	<br />\r\n</p>', null, null, '2014-04-02 10:39:45', '0', 'terminator的高效使用', '0');
INSERT INTO `article` VALUES ('9', 'zhagnsan', '2', '<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">我用的是Ubuntu的操作系统。之前碰到了一个问题： 为了方便登录公司机器，我经常修改/etc/hosts&nbsp;，让自己连接到别的机器方便些。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">但就在前段时间，我发现一个问题：每当我修改完/etc/hosts，在重启之后，会发现/etc/hosts会被还原。这个非常让人奇怪，以前并不会出现这个问题。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">经过一段时间的google，终于发现原来是由/etc/hosts.ac引起的！</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">每次重启的时候，你会发现/etc/hosts的内容就和/etc/hosts.ac的内容完全一样，当你改变/etc/hosts.ac的内容之后，重启机器，会发现/etc/hosts.ac的内容也被拷到/etc/hosts中去了。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">为什么会有/etc/hosts.ac？ 原来是公司的VPN从之前的Array VPN换成了思科提供的VPN，这样我就使用了思科的Any Connect VPN Client客户端。也正是这个客户端，新增了这个/etc/hosts.ac，想想ac就应该是Any Connect的简写了。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">至此，发现了问题，也就好解决了：</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<ul>\r\n		<li>\r\n			<span style=\"font-family:Microsoft YaHei;\">比较暴力的解决方式是：直接修改 /etc/hosts.ac 的内容。当然，你也可以写一个脚本去修改这个文件。</span>\r\n		</li>\r\n		<li>\r\n			<span style=\"font-family:Microsoft YaHei;\">比较优雅的解决方式是：我还没有找到，抛砖引玉，希望能听到你提供的优雅方案</span>\r\n		</li>\r\n	</ul>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:Microsoft YaHei;\">附上在google上搜索到的资料：</span><a href=\"http://ubuntuforums.org/showthread.php?t=1896148\"><span style=\"font-family:Microsoft YaHei;\">hosts file keeps getting reset/rewritten, hosts.ac the culprit</span></a>\r\n</p>', null, null, '2014-04-02 10:40:13', '0', '解决 ubuntu 的 /etc/hosts 重启就被还原', '0');
INSERT INTO `article` VALUES ('10', 'zhagnsan', '2', '<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">Java中的并发包，是在Java代码中并发程序的热门话题。如果我们去读concurrent包的源码时，会发现其真正的核心是 AbstractQueuedSynchronizer ， 简称 AQS 框架 , 而 Doug Lea 大神正是此包的作者。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">之前也看过一遍 AbstractQueuedSynchronize，但印象不深，只有依稀的印象。这次重新学习一遍，并整理出笔记，希望对自己或者是别人有用。当然了，笔者也是浅显的过一遍，很多细节也并不是完全理解。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">建议读者先看这个系列的文章：</span><a href=\"http://whitesock.iteye.com/blog/1336920\"><span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">Inside AbstractQueuedSynchronizer</span></a><span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">，之后再继续本篇。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">首先，AQS会对进行 acquire 而被阻塞的线程进行管理，说是管理，其实就是内部维护了一个FIFO队列，这个队列是一个双向链表。链头可以理解为是一个空的节点，除了链头以外，每个节点内部都持有着一个线程，同时，有着两个重要的字段：waitStatus 和 nextWaiter。nextWaiter一般是作用与在使用Condition时的队列。而waitStatus则有以下几个字段：</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<ul>\r\n		<li>\r\n			<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">SIGNAL&nbsp;表示下一个节点应该被唤醒。为什么是下一个节点？因为刚刚说了，这个FIFO队列，链头都是一个空的节点，但此节点的 waitStatus 正好就表示了要对下一节点做的事情</span>\r\n		</li>\r\n		<li>\r\n			<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">CANCELLED&nbsp;表示此节点持有的线程被中断，或者该线程为null了。节点只能是暂时停留在此状态，因为在线程进入AQS时，线程会找机会整理链表，包括删除CANCELLED状态的节点。</span>\r\n		</li>\r\n		<li>\r\n			<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">CONDITION&nbsp;表示此节点是在另一个队列中 —— condition队列中。比如我们使用的ReentrantLock.newCondition()获得Condition对象进行await时，在AQS内部所产生的节点。</span>\r\n		</li>\r\n		<li>\r\n			<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">PROPAGATE&nbsp;顾名思义，传播。这点比较难理解，需要仔细推敲。因为此状态是为共享同步器使用的。加入此状态，可以避免无谓的线程 park 和 unpark。按照我对代码的理解，这是对多个线程并发获取共享同步器(比如acquireShared)所进行的优化，至少有3个线程并发，但想要优化效果明显的话，可能需要几十个线程并发的获取共享同步器(比如acquireShared)，如果在并发量非常大的时候，对系统的吞吐量的作用应该不少。</span>\r\n		</li>\r\n	</ul>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">AbstractQueuedSynchronizer内置一个state字段，用来表示某种意义——当ReentrantLock使用AQS的时候，state被用来表示锁被重入的次数；当’Semaphore’使用AQS的时候，state则被用来表示当前还有多少信号量可被获取。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">AbstractQueuedSynchronizer 支持两种模式，分别是独占式和共享式。两者进行获取和释放动作的思路都是差不多的。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">获取同步器的流程如下：</span>\r\n</p>\r\n<div>\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">if(尝试获取成功){return;\r\n}else{\r\n  加入等待队列;\r\n  park自己;\r\n}</span>\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">释放同步器的流程如下：</span>\r\n</p>\r\n<div>\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">if(尝试释放成功){\r\n  unpark等待队列中第一个节点;\r\n}else{returnfalse;\r\n}</span>\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-family:\'Microsoft YaHei\';font-size:14px;\">只要环绕着这两个思路去看AQS中的代码，相信应该可以明白其中的主要原理。</span>\r\n</p>', null, null, '2014-04-02 10:40:49', '0', 'Java并发同步器AQS(AbstractQueuedSynchronizer)学习笔记(1)', '0');
INSERT INTO `article` VALUES ('11', 'zhagnsan', '2', '<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">学习了AbstractQueuedSynchronizer 之后(Condition没有在上文做笔记，当应该不难理解)，接下来笔者就尝试着分析在JUC包中的各个同步器，其语义是如何实现的。</span>\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">ReentrantLock</span>\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">内部类Sync继承了AbstractQueuedSynchronizer。state表示锁被重入的次数。因为其是独占锁，所以只实现了tryRelease，isHeldExclusively方法，而tryAcquire则交由子类基于公平和非公平的策略来实现。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">公平的ReentrantLock会在每次tryAcquire的时候，都老老实实让排在队列前面的线程优先拿锁。而非公平锁则是发现state为0后，就马上去尝试设置state，如果不能成功，才进入AQS内部的队列老老实实的排队。</span>\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">ReentrantReadWriteLock</span>\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">此类最为复杂。内部类Sync继承了AbstractQueuedSynchronizer，同时内部类ReadLock和WriteLock内部共享了Sync，state这个int被划分成两部分，高位16个bit表示共享读锁，低位16个bit表示独占写锁。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">大概的工作方式是：读锁使用shared模式，复写tryAcquireShared和tryReleaseShared；写锁使用独占锁，复写tryAcquire和tryRelease。当线程要求锁住写锁的时候，内部会检查state是否为0；如果不为0，则检查此时是写状态还是读状态；如果是写状态，则检查持有写锁的是否是自己；如果是的话，则进行锁重入。锁住读锁也是这个道理，只不过是使用的shared的锁模式而已。</span>\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">Semaphore</span>\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">使用state表示信号量。可以想象，使用是的shared模式。在acquire的时候，会去比较state来判断是否可以成功。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">需要注意的是此类如果使用不当，则可能会有线程被挂住的问题，测试代码可以参见这里：</span><a href=\"https://gist.github.com/3879133\"><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">https://gist.github.com/3879133</span></a><span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">。</span>\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">CountDownLatch</span>\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">与Semaphore一样，都是非常简单的使用了state。</span>\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">CyclicBarrier</span>\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">内部使用的是ReentrantLock，利用了Condition来唤醒栅栏前的线程。</span>\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">FutureTask</span>\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">使用state来表示任务的执行状态。代码也相对比较简单。值得注意的是，FutureTask对于任务执行抛出的异常，是会捕捉住的（在get的时候才会给抛给你），如果在编写任务时候没有catch(Exception)，而导致有异常漏过业务代码，则很有可能产生不可预知的问题。</span>\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<span style=\"font-size:14px;font-family:\'Microsoft YaHei\';\">比如，在使用 ScheduledExecutorService分发定时任务之后，而又不关心返回结果的时候，就可能会出现问题。所以一般对自己的线程，也应该处理自己线程的异常，这也是最佳实践的原则。</span>\r\n</p>', null, null, '2014-04-02 10:41:24', '0', 'Java并发同步器AQS(AbstractQueuedSynchronizer)学习笔记(2)', '0');
INSERT INTO `article` VALUES ('12', 'zhagnsan', '3', '<h3>\r\n	什么是模式\r\n</h3>\r\n<p>\r\n	我的理解：模式就是在某一场景下，针对某一问题，有着对应解决方案。\r\n</p>\r\n<p>\r\n	当有了这样一种模式。下次再碰到同样的场景，同样的问题，这种模式就可以解决掉这样的问题。\r\n</p>\r\n<p>\r\n	这里所说的某一场景、某一问题，并不具体化，而是抽象的。当解决完一个问题之后，从这个问题抽取出一种模式，并且将模式所能解决的场景/问题范化，到之后为更多的问题服务，才是模式的意义。\r\n</p>\r\n<h3>\r\n	模式并非单独存在\r\n</h3>\r\n<p>\r\n	使用某种模式，通常带来新的问题，而其中一些问题，可以使用别的模式去解决。 模式可以是包含和被包含的关系。\r\n</p>\r\n<p>\r\n	书中举的例子非常好：使用MVC模式会带来一个问题，即 model 更新之后，需要同时被 view 和 controller 知道，这时候，可以使用 观察者模式 来解决由 MVC 所带来的问题。\r\n</p>\r\n<p>\r\n	当然，使用观察者也一定会带来新的问题。 究竟要把问题解决到什么程度？ 那就要看我当初的目标了。 也就是：判断模式使用的成功程度，是取决于当初设计的目标是否实现。\r\n</p>\r\n<h3>\r\n	模式从作用范围由大到小分为三种\r\n</h3>\r\n<ul>\r\n	<li>\r\n		体系结构模式\r\n	</li>\r\n	<li>\r\n		设计模式\r\n	</li>\r\n	<li>\r\n		惯用法(idom)\r\n	</li>\r\n</ul>\r\n<p>\r\n	模式的学习不能仅仅依靠理论，还要实践，而且是需要工程级别的实践才能体会起优缺点。 接下来的学习笔记中，将逐渐慢慢的学习之。\r\n</p>', null, null, '2014-04-02 10:41:52', '0', '模式学习笔记之概述-1', '0');
INSERT INTO `article` VALUES ('13', 'zhagnsan', '2', '<p>\r\n	如果你使用git对你的产品进行版本管理，那么 git flow 是一个很适合你的分支管理模型。 英文版详见&nbsp;<a href=\"http://nvie.com/posts/a-successful-git-branching-model/\">这里</a> \r\n</p>\r\n<p>\r\n	之前使用了这个模型进行开发，觉得还不错, 于是有了这篇博客。 其实原文比此篇还要详细。只不过我加了一个例子，以及目前的心得:)\r\n</p>\r\n<p>\r\n	一共有4种类型的分支：\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<ol>\r\n	<li>\r\n		develop 分支(只有一个分支)\r\n	</li>\r\n	<li>\r\n		feature 分支(可以有很多分支)\r\n	</li>\r\n	<li>\r\n		release 分支(同一时间只有一个分支，而且生命周期很短，只是为了发布)\r\n	</li>\r\n	<li>\r\n		master 分支(只有一个分支)\r\n	</li>\r\n	<li>\r\n		hotfix 分支(同一时间只有一个分支，用来进行 bug 的一些开发和小版本的发布)\r\n	</li>\r\n</ol>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	对于 develop 分支，develop 是一个 Nightly Builds 的分支。merege 给 develop 的 commit，都是以 feature 为单位的。\r\n</p>\r\n<p>\r\n	当你有新的功能开发时，你需要创建 feature 分支来进行你的功能开发。此时的 feature 分支是 base 在 develop 分支的。当在某一功能完成之后，再把 feature 分支 merge 到 develop 分支上。\r\n</p>\r\n<p>\r\n	当有足够多的 feature merge 到了 develop 上，此时团队认为 develop 上的功能已经到了里程碑点，测试也已经OK了，就可以进行新版本的发布。这时，就到了需要创建 release 分支的时候。\r\n</p>\r\n<p>\r\n	releaes分支 base 在 develop分支 上。当 release 分支被创建之后，需要改一些发布的信息，比如版本号（如果你用的是maven，推荐使用 version 插件）。然后再 merge 到 master 分支上。之后，应该打一个 tag，这个tag就是发布的版本号了。在 release分支 merge 到 master分支之后，版本就发布完成了。接着，再把 release merge 到 develop 上，此时很可能有一些冲突，比如版本号，这时候就需要解决一些冲突，然后再次 merge 到 develop 上。之后删除 release分支。\r\n</p>\r\n<p>\r\n	这样，就完成了一个新版本的发布。可以看到，master 上的代码都是稳定——称为 stable build。\r\n</p>\r\n<p>\r\n	不过，软件都是有bug的。当正式的版本出现了bug，我们需要进行修复，此时就是 hotfix 出场的时候了。\r\n</p>\r\n<p>\r\n	新建的 hotfix 是 base 在 master 分支上的。当 hotfix 被建立的时候，你就可以在 hotfix 分支上进行 bug 的修复，可以修复一个 bug，也可以修复多个bug（具体要看你bug的紧急程度，和你项目的具体情况）。等到你觉得 hotfix 上的修复得差不多了，就可以把 hotfix 分支 merge 到 master 上，然后打一个 tag，标记为一个bug修复的小版本升级。接着，再把 hotfix merge 回 develop。最后，把 hotfix 删除。\r\n</p>\r\n<p>\r\n	这就是 git flow 分支模型的思路。在具体的操作层面， git flow 提供了便利的命令来帮助你完成上述动作。\r\n</p>\r\n<p>\r\n	<br />\r\n</p>\r\n<p>\r\n	现在很多团队开始转向 git，一个不错的分支模型就显得比较重要了。git flow 正好解决了这个问题。而且更重要的是，对于想跨团队共建代码的公司来说，分支模型的一致性，无疑会避免很多问题，这一点很关键。\r\n</p>', null, null, '2014-04-02 10:42:34', '0', '使用 git flow 进行产品分支的管理', '0');
INSERT INTO `article` VALUES ('14', 'zhagnsan', '2', '<p style=\"text-indent:2em;\">\r\n	我最近在中间件团队开发的一个技术产品（就叫他Tesla好了），就是使用了这一个模型。在我还没有接触到 git-flow 的时候，Tesla就已经开发好一阵子了。还好，这并不影响先有产品对 git-flow 的使用。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	由于我用的是 ubuntu，所以在安装方面，会简单很多（别担心，如果你是其他操作系统，也会有相应的<a href=\"https://github.com/nvie/gitflow/wiki/Installation\">安装步骤</a>）\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	我先开始安装 git flow\r\n</p>\r\n<div>\r\n	sudo apt-get install git-flow\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	然后再安装 git flow 等一些自动补齐工具\r\n</p>\r\n<div>\r\n	sudo apt-get install bash-completion\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	接着再我的 tesla 工作目录进行 git flow 初始化\r\n</p>\r\n<div>\r\n	git flow init\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	git flow 会询问你一些分支名称的设置，我一路回车，使用默认值。 现在，我已经在 develop 的分支下面了。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	当我开始开发一个新的 feature 时候，需要进行以下操作：\r\n</p>\r\n<div>\r\n	git flow feature start issue_1\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	这时候，git flow 已经帮我建立好了 feature/issue_1 这个分支，并且已经 co 出了此分支\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	当我在 feature/issue1 分支上开发好了issue1 这个功能时，我会进行如下操作：\r\n</p>\r\n<div>\r\n	git flow feature finish issue_1\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	这样， feature/issue1 就会被merge到develop分支上，并且feature/issue1分支已经被删除，我又再develop分支上了。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	当我需要发布一个正常版本的时候，我会进行如下操作：\r\n</p>\r\n<div>\r\n	git flow release start v0.1\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	这样，git flow 就会帮我从 develop分支上拉出一个 release/v0.1 的分支。 我需要在这个分支上做一些修改，比如版本号的改动,然后拿去做测试，确认可以发布后，使用:\r\n</p>\r\n<div>\r\n	git flow release finish v0.1\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	这样， git flow 就自动帮我把 release/v0.1 merge 到 master 分支上，接着，也会将 release/v0.1 merge 回 develop 上。 与此同时，git flow 还会帮我把 release/v0.1 打好 v0.1 的 tag。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	发布的时候，只需要将 tag 为 v0.1 的版本 checkout 出来，然后去做部署即可。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	当 v0.1 这个版本被反馈出有好几处bug的时候，我们需要这么操作：\r\n</p>\r\n<div>\r\n	git flow hotfix start v0.11\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	这样，git flow 就会帮我从 master 分支上拉出一个 hotfix/v0.11 的分支。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	我在这个分支上修改这几个bug，并且测试完毕。接着执行：\r\n</p>\r\n<div>\r\n	git flow hotfix finish v0.11\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	贴心的 git flow 就会帮我把 hotfix/v0.11 这个分支 merge 到 master 上，然后 merge 回 develop 上。 接着，还会打好 v0.11 这个 tag，这就是 tesla 的小版本发布了。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	完成之后，我又开始了正常 feature 的开发……\r\n</p>', null, null, '2014-04-02 10:42:57', '0', '使用 git flow 进行产品分支的管理2', '0');
INSERT INTO `article` VALUES ('15', 'zhagnsan', '5', '<p style=\"text-indent:2em;\">\r\n	最近在使用 Jekyll 这个博客系统，而 Jekyll 里面使用的模板引擎为 Liquid。于是，就想对读读 Liquid 的源码，并利用这篇文章做一些笔记。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	Liquid（其实应该是任何模板功能）分为parse和render阶段。 值得一提的是 Liquid 使用了非常简单的方式来构建模板，因此它就使用了正则表达式来进行 parse。 Template 是Liquid的核心类，也是入口类。 通常用户使用 Template 来使用进行 parse 和 render。\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	parse\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	在 Template 的 tokenize 方法中进行 token 的分解，核心就是使用了 string 的 split 方法。 这里需要注意的是， split 中可以接受正则表达式，如果正则表达式中，有group的写法（其实就是带有括号分组），那么在返回的数组中，也会把匹配的字符串带上。 Liquid 的 tokenize 阶段就是使用了这个特性来完成 token 分解的。 下面是我的测试代码：\r\n</p>\r\n<div>\r\n	text =\"{{asd}} sdfadsf afas {% a %}xxx{% enda %} asdfa asdf s af \"text.split(Liquid::TemplateParser)# result:[\"\",\"{{asd}}\",\" sdfadsf afas \",\"{% a %}\",\"xxx\",\"{% enda %}\",\" asdfa asdf s af \"]\r\n</div>\r\n<p style=\"text-indent:2em;\">\r\n	看到这个结果，也就对 tokenize 输出的结果不难理解了。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	接下来，就新建一个 Document 对象，对刚刚生成的 tokens（其实就是一个数组）进行 parse。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	具体是代码在 Document 的构造函数中，里面调用了 parse 方法，而 parse 方法是继承自 Block 对象中的。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	Block 中的 parse 方法，会对刚刚解析出来的 tokens 轮循做解析，一旦发现是 tags 或者是 var，则 new 相应的 Tag 或者 Variable，或者不是这两者，则干脆就生成对象，就是直接当作字符串，然后这三者——tag，variable，字符串——都放到了一个叫 nodelist 的数组中。\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	render\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	接着就是进入 render 的步骤了。需要说明的是，之前 parse 出来的结果，其实可以作缓存的，因为 render 只是把不同的变量和 filter 放到固定的模板中来显示不同的效果而已。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	render 就是一个递归的过程。从 doucment 到各种不同的 tag，都会执行 render 方法，如果该 token 没有 render 方法，那么就直接返回该 toekn，一般来说，这应该都是 string 类型的 token。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	render 过程中，最重要的就是 context 这个对象，可以仔细看看，其中我觉得最重要的一点就是scope的范围变得很不重要——如果你需要在context中寻找一个变量，那么此context将在所有的scope中寻找，知道找到为止，如果找不到，也会在所谓的 environment 中去寻找。（个人觉得 context 对于理解 liquid 非常重要，需要仔细琢磨，后续这里再展开)\r\n</p>\r\n<h3 style=\"text-indent:2em;\">\r\n	一些场景\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	这里会列举几个我能想象到的场景以及解决方法。\r\n</p>\r\n<h4 style=\"text-indent:2em;\">\r\n	数组赋值\r\n</h4>\r\n<p style=\"text-indent:2em;\">\r\n	可以扩展 tag 或者 block，具体可以看看 liquid 中各种 tag 的写法。这里我扩展一下 capture, liquid 中 capture 是赋值的tag，相当于是 a = b 的形式，现在我扩展成一个 block, 并且把 block 里面的东西加入到一个数组中，以便在之后某个时刻模板上运行一个遍历。\r\n</p>\r\n<div>\r\n	moduleZavakidclassCaptureArrayBlock&lt;Liquid::BlockincludeLiquid::StandardFiltersSYNTAX=/(\\w+)/definitialize(tag_name, markup, tokens)superifmarkup.strip =~SYNTAX@to=$1elseraiseSyntaxError.new(\"Syntax Error in \'captureArray\' - Valid syntax: captureArray var\")endenddefrender(context)text =supercontext.scopes.last[@to] =Array.newunlesscontext.scopes.last[@to]\r\n      var = context.scopes.last[@to]\r\n      var.push(text)\'\'endendendLiquid::Template.register_tag(\'captureArray\',Zavakid::CaptureArrayBlock)\r\n</div>\r\n<h4 style=\"text-indent:2em;\">\r\n	代码高亮\r\n</h4>\r\n<p style=\"text-indent:2em;\">\r\n	其实就是我正在用的这种高亮，其实扩展起来也相对容易，需要解决的一个问题就是不去parse高亮快中的 liquid tag，参考了 jekyll 的 highlight 和 liquid 的 raw，见代码：\r\n</p>\r\n<div>\r\n	moduleZavakidclassHlBlock&lt;Liquid::BlockincludeLiquid::StandardFiltersSYNTAX=/^([a-zA-Z0-9.+#-]+)((\\s+\\w+(=\\w+)?)*)$/definitialize(tag_name, markup, tokens)superifmarkup.strip =~SYNTAX@lang=$1elseraiseSyntaxError.new(\"Syntax Error in \'highlight\' - Valid syntax: hl &lt;lang&gt; [linenos]\")endenddefparse(tokens)@nodelist||= []@nodelist.clearwhiletoken = tokens.shiftiftoken =~FullTokenifblock_delimiter ==$1end_tagreturnendend@nodelist&lt;&lt; tokenifnottoken.empty?endenddefrender(context)render_hl(context,super)enddefrender_hl(context, code)#根据自己需要对code做修饰endendendLiquid::Template.register_tag(\'hl\',Zavakid::HlBlock)\r\n</div>\r\n<h3 style=\"text-indent:2em;\">\r\n	总结\r\n</h3>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	liquid 的实现比较轻巧，不是我之前想像的死板的tokenize，而是利用了正则表达式来解决掉token的问题，然后再使用各个tag来递归parse。 这种思路还是很值得学习的。下次可以自己尝试也写一个 liquid 的 java 版本。\r\n</p>', null, null, '2014-04-02 10:43:22', '0', 'Liquid学习', '0');
INSERT INTO `article` VALUES ('16', 'zhagnsan', '2', '<h3 style=\"text-indent:2em;\">\r\n	<p>\r\n		自从买了kindle后，总是想着如何最大效用发挥其效用。虽然多看上有很多书可以购买，网上也有很多免费的电子书，但是仍然有很多感兴趣的内容是以网页的形式存在的。例如<a href=\"http://chimera.labs.oreilly.com/books/\">O’Reilly Atlas</a>就提供了诸多电子书，但是只提供免费的在线阅读；另外还有很多资料或文档都只有网页形式。于是就希望通过某种方法讲这些在线资料转为epub或mobi格式，以便在kindle上阅读。这篇文章介绍了如何借助calibre并编写少量代码来达到这个目的。\r\n	</p>\r\n</h3>\r\n<h1 style=\"text-indent:2em;\">\r\n	Calibre\r\n</h1>\r\n<h2 style=\"text-indent:2em;\">\r\n	Calibre简介\r\n</h2>\r\n<p style=\"text-indent:2em;\">\r\n	<a href=\"http://calibre-ebook.com/\">Calibre</a>是一个免费的电子书管理工具，可以兼容Windows, OS X及Linux，令人欣喜的是，除了GUI外，calibre还提供了诸多命令行工具，其中的ebook-convert命令可以根据用户编写的recipes文件（实际是python代码）抓取指定页面内容并生成mobi等格式的电子书。通过编写recipes可以自定制抓取行为，以适应不同的网页结构。\r\n</p>\r\n<p style=\"text-indent:2em;\">\r\n	<br />\r\n</p>', null, null, '2014-04-02 10:44:21', '0', '使用Ant构建web项目', '0');
INSERT INTO `article` VALUES ('17', 'zhagnsan', '2', '顶顶顶顶顶顶顶顶顶顶顶顶顶', null, null, '2014-04-02 10:45:00', '0', '顶顶顶顶顶顶顶顶顶顶顶顶顶', '0');
INSERT INTO `article` VALUES ('18', 'zhagnsan', '2', '顶顶顶顶顶顶顶顶顶顶顶顶顶', null, null, '2014-04-02 10:45:03', '0', '顶顶顶顶顶顶顶顶顶顶顶顶顶', '0');
INSERT INTO `article` VALUES ('19', 'zhagnsan', '2', '顶顶顶顶顶顶顶顶顶顶顶顶顶', null, null, '2014-04-02 10:45:07', '0', '顶顶顶顶顶顶顶顶顶顶顶顶顶', '0');
INSERT INTO `article` VALUES ('20', 'zhagnsan', '2', '顶顶顶顶顶顶顶顶顶顶顶顶顶', null, null, '2014-04-02 10:45:12', '0', '顶顶顶顶顶顶顶顶顶顶顶顶顶', '0');
INSERT INTO `article` VALUES ('21', 'zhagnsan', '2', '顶顶顶顶顶顶顶顶顶顶顶顶顶', null, null, '2014-04-02 10:45:16', '0', '顶顶顶顶顶顶顶顶顶顶顶顶顶', '0');
INSERT INTO `article` VALUES ('22', 'zhagnsan', '5', '正在生成 D:\\workspace\\Ant\\doc\\api\\junit\\allclasses-frame.html...', null, null, '2014-04-02 10:55:24', '0', '2014并发网招募主编和译者', '0');

-- ----------------------------
-- Table structure for `blog`
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_num` int(11) DEFAULT NULL,
  `background` varchar(255) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `mail_notice` bit(1) DEFAULT NULL,
  `phone_notice` bit(1) DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  `banner_color` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES ('1', '0', '255,251,240', '跟着自己的脚步，踏踏实实的往前走', '', '', 'KrisJin点滴技术路程', '240,252,255');

-- ----------------------------
-- Table structure for `category`
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_number` int(11) DEFAULT NULL,
  `name` varchar(255) NOT NULL,
  `order_value` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES ('1', '2', 'Linux命令', '2');
INSERT INTO `category` VALUES ('2', '0', 'Http协议', '1');
INSERT INTO `category` VALUES ('3', '0', 'Spring框架', '3');
INSERT INTO `category` VALUES ('4', '0', 'Git使用', '4');
INSERT INTO `category` VALUES ('5', '0', '网络通信', '5');

-- ----------------------------
-- Table structure for `color`
-- ----------------------------
DROP TABLE IF EXISTS `color`;
CREATE TABLE `color` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `code` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=130 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of color
-- ----------------------------
INSERT INTO `color` VALUES ('1', '255,179,167', '粉红，即浅红色。别称：妃色杨妃色湘妃色妃红色。', '粉红');
INSERT INTO `color` VALUES ('2', '237,87,54', '妃红色：古同“绯”，粉红色。杨妃色 湘妃色 粉红皆同义。', '妃色');
INSERT INTO `color` VALUES ('3', '240,0,86', '比大红浅的红色', '品红');
INSERT INTO `color` VALUES ('4', '244,121,131', '桃花的颜色，比粉红略鲜润的颜色', '桃红');
INSERT INTO `color` VALUES ('5', '219,90,107', '淡紫红色、较桃红色深一些，是非常妩媚娇艳的颜色', '海棠红');
INSERT INTO `color` VALUES ('6', '242,12,0', '石榴花的颜色，高色度和纯度的红色', '石榴红');
INSERT INTO `color` VALUES ('7', '201,55,86', '鲜红色', '樱桃色');
INSERT INTO `color` VALUES ('8', '240,86,84', '银朱和粉红色颜料配成的颜色。多用来形容有光泽的各种红色，尤指有光泽浅红', '银红');
INSERT INTO `color` VALUES ('9', '255,33,33', '正红色，三原色中的红，传统的中国红，又称绛色', '大红');
INSERT INTO `color` VALUES ('10', '140,67,86', '紫中略带红的颜色', '绛紫');
INSERT INTO `color` VALUES ('11', '200,60,35', '艳丽的深红', '绯红');
INSERT INTO `color` VALUES ('12', '157,41,51', '1，女子装扮时用的胭脂的颜色。 2，国画暗红色颜料', '胭脂');
INSERT INTO `color` VALUES ('13', '255,76,0', '朱砂的颜色，比大红活泼，也称铅朱朱色丹色', '朱红');
INSERT INTO `color` VALUES ('14', '255,78,32', '丹砂的鲜艳红色', '丹');
INSERT INTO `color` VALUES ('15', '243,83,54', '赤色', '彤');
INSERT INTO `color` VALUES ('16', '203,58,86', '茜草染的色彩，呈深红色', '茜色');
INSERT INTO `color` VALUES ('17', '255,45,81', '火焰的红色，赤色', '火红');
INSERT INTO `color` VALUES ('18', '201,31,55', '深红，火红。泛指赤色、火红色', '赫赤');
INSERT INTO `color` VALUES ('19', '239,122,130', '鲜艳的红色', '嫣红');
INSERT INTO `color` VALUES ('20', '255,0,151', '色橘红', '洋红');
INSERT INTO `color` VALUES ('21', '255,51,0', '引申为红色', '炎');
INSERT INTO `color` VALUES ('22', '195,39,43', '本义火的颜色，即红色', '赤');
INSERT INTO `color` VALUES ('23', '169,129,117', '绛色；浅绛色', '绾');
INSERT INTO `color` VALUES ('24', '195,33,54', '即深红', '枣红');
INSERT INTO `color` VALUES ('25', '179,109,97', '浅红色，浅绛色', '檀');
INSERT INTO `color` VALUES ('26', '190,0,47', '发黑的红色', '殷红');
INSERT INTO `color` VALUES ('27', '220,48,35', '像饮酒后脸上泛现的红色，泛指脸红', '酡红');
INSERT INTO `color` VALUES ('28', '249,144,111', '饮酒脸红的样子。亦泛指脸红色', '酡颜');
INSERT INTO `color` VALUES ('29', '255,241,67', '淡黄色', '鹅黄');
INSERT INTO `color` VALUES ('30', '250,255,114', '小鸭毛的黄色', '鸭黄');
INSERT INTO `color` VALUES ('31', '234,255,86', '淡黄色', '樱草色');
INSERT INTO `color` VALUES ('32', '255,166,49', '成熟杏子的黄色', '杏黄');
INSERT INTO `color` VALUES ('33', '255,140,​​49', '成熟杏子偏红色的一种颜色', '杏红');
INSERT INTO `color` VALUES ('34', '255,137,54', '柑橘的黄色', '橘黄');
INSERT INTO `color` VALUES ('35', '255,164,0', '橙的黄色。 （现代感比较强。广告上用得较多）', '橙黄');
INSERT INTO `color` VALUES ('36', '255,117,0', '柑橘皮所呈现的红色', '橘红');
INSERT INTO `color` VALUES ('37', '255,199,115', '橙的黄色。 （现代感比较强。广告上用得较多）', '姜黄');
INSERT INTO `color` VALUES ('38', '240,194,57', '浅黄色', '缃色');
INSERT INTO `color` VALUES ('39', '250,140,​​53', '界于红色和黄色之间的混合色', '橙色');
INSERT INTO `color` VALUES ('40', '179,92,68', '一种比栗色稍红的棕橙色至浅棕色', '茶色');
INSERT INTO `color` VALUES ('41', '168,132,98', '一种比哢叽色稍红而微淡、比肉桂色黄而稍淡和比核桃棕色黄而暗的浅黄棕色', '驼色');
INSERT INTO `color` VALUES ('42', '178,93,37', '棕毛的颜色,即褐色。 1，在红色和黄色之间的任何一种颜色2，适中的暗淡和适度的浅黑', '棕色');
INSERT INTO `color` VALUES ('43', '124,75,0', '深​​棕色', '棕黑');
INSERT INTO `color` VALUES ('44', '202,105,36', '无', '琥珀');
INSERT INTO `color` VALUES ('45', '149,85,57', '红色、赤红色。古人用以饰面', '赭色');
INSERT INTO `color` VALUES ('46', '211,177,125', '干枯焦黄', '枯黄');
INSERT INTO `color` VALUES ('47', '226,156,69', '一种落叶灌木，花黄绿色,叶子秋天变成红色。木材黄色可做染料', '黄栌');
INSERT INTO `color` VALUES ('48', '137,108,57', '1，中常橄榄棕色,它比一般橄榄棕色稍暗,且稍稍绿些。 2，古以秋为金,其色白,故代指白色', '秋色');
INSERT INTO `color` VALUES ('49', '189,221,3', '像刚长出的嫩叶的浅绿色', '嫩绿');
INSERT INTO `color` VALUES ('50', '120,146,98', '竹子的绿色', '竹青');
INSERT INTO `color` VALUES ('51', '163,217,0', '黄绿色，嫩黄色', '葱青');
INSERT INTO `color` VALUES ('52', '10,163,68', '翠绿色,形容植物浓绿', '青葱');
INSERT INTO `color` VALUES ('53', '0,188,18', '光润而浓绿的颜色。以上几种绿色都是明亮可爱的色彩', '油绿');
INSERT INTO `color` VALUES ('54', '12,137,24', '深绿', '绿沉');
INSERT INTO `color` VALUES ('55', '27,209,165', '1，青绿色。 2，青白色,浅蓝色', '碧色');
INSERT INTO `color` VALUES ('56', '42,221,156', '鲜艳的青绿色', '碧绿');
INSERT INTO `color` VALUES ('57', '72,192,163', '鲜艳的青蓝色', '青碧');
INSERT INTO `color` VALUES ('58', '61,225,173', '1，翡翠鸟羽毛的青绿色。 2，翡翠宝石的颜色。 (注：C-Y≧30 的系列色彩，多与白色配合以体现清新明丽感觉，与黑色配合效果不好：该色个性柔弱，会被黑色牵制)', '翡翠色');
INSERT INTO `color` VALUES ('59', '64,222,90', '绿而略黄的颜色', '草绿');
INSERT INTO `color` VALUES ('60', '0,224,158', '1，一类带绿的蓝色,中等深浅,高度饱和。 3，本义是蓝色。 4，一般指深绿色。 5，也指黑色。 6，四色印刷中的一色。 2，特指三补色中的一色。', '青色');
INSERT INTO `color` VALUES ('61', '0,224,121', '鲜绿', '青翠');
INSERT INTO `color` VALUES ('62', '192,235,215', '白而发青,尤指脸没有血色', '青白');
INSERT INTO `color` VALUES ('63', '224,238,232', '淡青灰色，极淡的青绿色', '鸭卵青');
INSERT INTO `color` VALUES ('64', '187,205,197', '深灰绿色', '蟹壳青');
INSERT INTO `color` VALUES ('65', '66,76,80', '鸦羽的颜色。即黑而带有紫绿光的颜色', '鸦青');
INSERT INTO `color` VALUES ('66', '158,208,72', '浅黄绿色', '豆绿');
INSERT INTO `color` VALUES ('67', '150,206,84', '浅青绿色', '豆青');
INSERT INTO `color` VALUES ('68', '123,207,166', '淡灰绿色', '石青');
INSERT INTO `color` VALUES ('69', '46,223,163', '玉的颜色，高雅的淡绿、淡青色', '玉色');
INSERT INTO `color` VALUES ('70', '127,236,173', '绿色而微白', '缥');
INSERT INTO `color` VALUES ('71', '164,226,198', '艾草的颜色。偏苍白的绿色', '艾绿');
INSERT INTO `color` VALUES ('72', '33,166,117', '经冬松柏叶的深绿', '松柏绿');
INSERT INTO `color` VALUES ('73', '5,119,72', '亦作“松花”、“松绿”。偏黑的深绿色,墨绿', '松花绿');
INSERT INTO `color` VALUES ('74', '68,206,246', '三原色的一种。像晴天天空的颜色（注：这里的蓝色指的不是RGB色彩中的B，而是CMY色彩中的C）', '蓝');
INSERT INTO `color` VALUES ('75', '23,124,176', '也叫“蓝靛”。用蓼蓝叶泡水调和与石灰沉淀所得的蓝色染料。呈深蓝绿色 （注：有些地方将蓝墨水称为“靛水”或者“兰靛水”）', '靛青');
INSERT INTO `color` VALUES ('76', '6,82,121', '由植物(例如靛蓝或菘蓝属植物)得到的蓝色染料', '靛蓝');
INSERT INTO `color` VALUES ('77', '62,237,231', '青蓝色', '碧蓝');
INSERT INTO `color` VALUES ('78', '112,243,255', '类似晴朗天空的颜色的一种蓝色', '蔚蓝');
INSERT INTO `color` VALUES ('79', '75,92,196', '鲜艳明亮的蓝色（注：英文中为RoyalBlue 即皇家蓝色，是皇室选用的色彩，多和小面积纯黄色（金色）配合使用。 ）', '宝蓝');
INSERT INTO `color` VALUES ('80', '161,175,201', '一种近于灰略带蓝的深灰色', '蓝灰色');
INSERT INTO `color` VALUES ('81', '46,78,126', '蓝而近黑', '藏青');
INSERT INTO `color` VALUES ('82', '59,46,126', '蓝里略透红色', '藏蓝');
INSERT INTO `color` VALUES ('83', '74,66,102', '青黑色的颜料。古代女子用以画眉', '黛');
INSERT INTO `color` VALUES ('84', '66,102,102', '墨绿', '黛绿');
INSERT INTO `color` VALUES ('85', '66,80,102', '深蓝色', '黛蓝');
INSERT INTO `color` VALUES ('86', '87,66,102', '深紫色', '黛紫');
INSERT INTO `color` VALUES ('87', '129,84,99', '浑浊的紫色', '紫酱');
INSERT INTO `color` VALUES ('88', '129,84,118', '紫中略带红的颜色', '酱紫');
INSERT INTO `color` VALUES ('89', '76,34,27', '檀木的颜色，也称乌檀色乌木色', '紫檀');
INSERT INTO `color` VALUES ('90', '0,51,113', '纯度较低的深紫色', '绀青');
INSERT INTO `color` VALUES ('91', '86,0,79', '黑红色', '紫棠');
INSERT INTO `color` VALUES ('92', '76,141,174', '深蓝色', '群青');
INSERT INTO `color` VALUES ('93', '176,164,227', '浅蓝紫色', '雪青');
INSERT INTO `color` VALUES ('94', '204,164,227', '紫丁香的颜色，浅浅的紫色，很娇柔淡雅的色彩', '丁香色');
INSERT INTO `color` VALUES ('95', '237,209,216', '浅灰而略带红的颜色', '藕色');
INSERT INTO `color` VALUES ('96', '228,198,208', '浅紫而略带红的颜色', '藕荷色');
INSERT INTO `color` VALUES ('97', '117,135,138', '即各种颜色掺入黑色后的颜色，如苍翠', '苍色');
INSERT INTO `color` VALUES ('98', '81,154,115', '无', '苍黄');
INSERT INTO `color` VALUES ('99', '162,155,124', '无', '苍青');
INSERT INTO `color` VALUES ('100', '115,151,171', '无', '苍黑');
INSERT INTO `color` VALUES ('101', '209,217,224', '无', '苍白');
INSERT INTO `color` VALUES ('102', '136,173,166', '无', '水色');
INSERT INTO `color` VALUES ('103', '243,211,231', '无', '水红');
INSERT INTO `color` VALUES ('104', '212,242,231', '无', '水绿');
INSERT INTO `color` VALUES ('105', '210,240,244', '无', '水蓝');
INSERT INTO `color` VALUES ('106', '211,224,243', '无', '淡青');
INSERT INTO `color` VALUES ('107', '255,255,255', '纯白，洁白，净白，粉白', '精白');
INSERT INTO `color` VALUES ('108', '255,251,240', '乳白色', '像牙白');
INSERT INTO `color` VALUES ('109', '240,252,255', '如雪般洁白', '雪白');
INSERT INTO `color` VALUES ('110', '214,236,240', '淡蓝色', '月白');
INSERT INTO `color` VALUES ('111', '186,202,198', '金属氧化后的色彩', '老银');
INSERT INTO `color` VALUES ('112', '167,142,68', '无', '乌金');
INSERT INTO `color` VALUES ('113', '84,150,136', '无', '铜绿');
INSERT INTO `color` VALUES ('114', '233,231,239', '带银光的白色', '银白');
INSERT INTO `color` VALUES ('115', '234,205,118', '平均为深黄色带光泽的颜色', '金色');
INSERT INTO `color` VALUES ('116', '深黑色、泛指黑色', '无', '65,85,93');
INSERT INTO `color` VALUES ('117', '93,81,60', '黑中带黄的颜色', '黝');
INSERT INTO `color` VALUES ('118', '57,47,65', '深黑', '乌黑');
INSERT INTO `color` VALUES ('119', '22,24,35', '非常黑的', '漆黑');
INSERT INTO `color` VALUES ('120', '240,240,244', '铅粉的白色。铅粉，国画颜料，日久易氧化“返铅”变黑。铅粉在古时用以搽脸的化妆品。 （注：冷白）', '玄青');
INSERT INTO `color` VALUES ('121', '238,222,176', '与像牙相似的淡黄色（注：暖白）', '牙色');
INSERT INTO `color` VALUES ('122', '128,128,128', '黑色和白色混和成的一种颜色', '灰色');
INSERT INTO `color` VALUES ('123', '227,239,253', '晶莹洁白', '莹白');
INSERT INTO `color` VALUES ('124', '252,239,232', '似鱼腹部的颜色，多指黎明时东方的天色颜色', '鱼肚白');
INSERT INTO `color` VALUES ('125', '194,204,208', '白色和黑色混杂的。斑白的 夹杂有灰色的白', '花白');
INSERT INTO `color` VALUES ('126', '233,241,246', '白霜的颜色', '霜色');
INSERT INTO `color` VALUES ('127', '242,190,69', '足金的颜色', '赤金');
INSERT INTO `color` VALUES ('128', '98,42,29', '赤黑色，黑中带红的颜色，又泛指黑色', '玄色');
INSERT INTO `color` VALUES ('129', '117,138,153', '即黑灰', '墨灰');

-- ----------------------------
-- Table structure for `comment`
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) DEFAULT NULL,
  `comment_content` varchar(255) DEFAULT NULL,
  `comment_date` datetime DEFAULT NULL,
  `comment_nickname` varchar(255) DEFAULT NULL,
  `comment_user` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('1', '2', 'comments', '2014-04-01 21:23:35', '笑傲江湖', null, 'shi@128.com');
INSERT INTO `comment` VALUES ('2', '2', '颜色表大全_百度文库', '2014-04-01 22:11:08', '乔峰', null, 'a@126.com');
INSERT INTO `comment` VALUES ('3', '2', 'dsafsdafsa', '2014-04-02 10:18:27', 'dffd', null, 'shijinguijavafan@163.com');
INSERT INTO `comment` VALUES ('4', '2', 'sdfsdafsa', '2014-04-02 10:18:34', 'fsdafa', null, 'aaaafdsfd@aa.com');
INSERT INTO `comment` VALUES ('5', '2', 'fdsafsadfas', '2014-04-02 10:18:39', 'dfsdafs', null, 'shijinguijavafan@163.com');
INSERT INTO `comment` VALUES ('6', '2', '的顶顶顶顶顶顶顶顶顶顶', '2014-04-02 10:18:48', '德辅道', null, 'shijinguijavafan@163.com');
INSERT INTO `comment` VALUES ('7', '2', '顶顶顶顶顶顶顶顶顶顶顶顶顶顶', '2014-04-02 10:19:01', '哥哥哥哥哥哥', null, 'krisibm@163.com');
INSERT INTO `comment` VALUES ('8', '2', '发生大发萨菲', '2014-04-02 10:19:10', '对方答复', null, 'krisibm@163.com');
INSERT INTO `comment` VALUES ('9', '2', '地方萨芬', '2014-04-02 10:19:18', '都是', null, 'shijinguijavafan@163.com');
INSERT INTO `comment` VALUES ('10', '2', '上的发的萨菲', '2014-04-02 10:19:30', '发生的', null, 'krisibm@163.com');
INSERT INTO `comment` VALUES ('11', '2', '顶顶顶顶顶法啊啊啊啊啊啊啊啊啊啊阿', '2014-04-02 10:19:52', '东方少达', null, 'shijinguijavafan@163.com');
INSERT INTO `comment` VALUES ('12', '2', '的福克斯的开发了撒uioere', '2014-04-02 10:20:04', '亲戚', null, 'shijinguijavafan@163.com');
INSERT INTO `comment` VALUES ('13', '2', '吊死扶伤大', '2014-04-02 10:20:14', '累累累', null, 'shijinguijavafan@163.com');
INSERT INTO `comment` VALUES ('14', '2', '的发生范德萨发发生发生', '2014-04-02 10:20:27', '烦烦烦', null, 'shijinguijavafan@163.com');
INSERT INTO `comment` VALUES ('15', '2', '的发生发的萨芬', '2014-04-02 10:20:38', '姥姥', null, 'shijinguijavafan@163.com');
INSERT INTO `comment` VALUES ('16', '2', '的发生范德萨发', '2014-04-02 10:20:50', '热热', null, 'shijinguijavafan@163.com');

-- ----------------------------
-- Table structure for `user`
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  `blog_id` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FK36EBCB7474B930` (`blog_id`),
  CONSTRAINT `FK36EBCB7474B930` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', '1c4ca4238a0b923820dcc509a6f75849b.jpg', null, 'admin', 'c4ca4238a0b923820dcc509a6f75849b', 'admin', null);
